/*
 *   Created by Carsten on 12/06/2015.
 *   Copyright (c) 2015 Carsten Strunk
 *
 *   This Source Code Form is subject to the terms of the Mozilla Public
 *   License, v. 2.0. If a copy of the MPL was not distributed with this
 *   file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Hybrid Objecst Hardware Interface API
 * 
 * This API is intended for users who want to create their own hardware interfaces.
 * To create a new hardware interface create a folder under hardwareInterfaces and create the file index.js.
 * You should take a look at /hardwareInterfaces/emptyExample/index.js to get started.
 */



var http = require('http');
var utilities = require(__dirname + '/utilities');
var _ = require('lodash');

//global variables, passed through from server.js
var objects;
var objectLookup;
var globalVariables;
var dirnameO;
var nodeAppearanceModules;
var callback;
var Node;

//data structures to manage the IO points generated by the API user
function HardwareInterface() {
    this.objects = {};
}

function Object(objectName) {
    this.name = objectName;
    this.nodes = {};
}

function EmptyNode(nodeName) {
    this.name = nodeName;
}

var hardwareInterfaces = {};


/*
 ********** API FUNCTIONS *********
 */


/**
 * @desc This function writes the values passed from the hardware interface to the HybridObjects server.
 * @param {string} objectName The name of the HybridObject
 * @param {string} nodeName The name of the IO point
 * @param {} number The value to be passed on
 * @param {string} mode specifies the datatype of value, you can define it to be whatever you want. For example 'f' could mean value is a floating point variable.
**/
exports.writeIOToServer = function (objectName, nodeName, number, mode, unit, unitMin, unitMax) {
    if(typeof mode === 'undefined')  mode = "f";
    if(typeof unit === 'undefined')  unit = false;
    if(typeof unitMin === 'undefined')  unitMin = 0;
    if(typeof unitMax === 'undefined')  unitMax = 1;

    var objectKey = utilities.readObject(objectLookup, objectName); //get globally unique object id
  //  var valueKey = nodeName + objKey2;

    //console.log(objectLookup);

//    console.log("writeIOToServer obj: "+objectName + "  name: "+nodeName+ "  value: "+value+ "  mode: "+mode);

    if (objects.hasOwnProperty(objectKey)) {
        if (objects[objectKey].nodes.hasOwnProperty(nodeName)) {
           var thisItem = objects[objectKey].nodes[nodeName].item;
            thisItem.number = number;
            thisItem.mode = mode;
            thisItem.unit = unit;
            thisItem.unitMin = unitMin;
            thisItem.unitMax = unitMax;
            //callback is objectEngine in server.js. Notify data has changed.
            callback(objectKey, nodeName, thisItem, objects, nodeAppearanceModules);
        }
    }
};

/**
 * @desc clearIO() removes IO points which are no longer needed. It should be called in your hardware interface after all addIO() calls have finished.
 * @param {string} type The name of your hardware interface (i.e. what you put in the type parameter of addIO())
**/
exports.clearIO = function (type) {
    if(hardwareInterfaces.hasOwnProperty(type)) { //check if IO points of the specified type have been added
        for (var objectName in hardwareInterfaces[type].objects) {
           var objectID = utilities.getObjectIdFromTarget(objectName, dirnameO);

            if (!_.isUndefined(objectID) && !_.isNull(objectID) && objectID.length > 13) {
                for (var key in objects[objectID].nodes) {
                    if (!hardwareInterfaces[type].objects[objectName].nodes.hasOwnProperty(objects[objectID].nodes[key].name)) {
                        if (globalVariables.debug) console.log("Deleting: " + objectID + "   " + key);
                        delete objects[objectID].nodes[key];
                    }
                }

            }

        }
    }
    //TODO: clear links too
    if (globalVariables.debug) console.log("it's all cleared");
};


/**
 * @desc addIO() a new IO point to the specified HybridObject
 * @param {string} objectName The name of the HybridObject
 * @param {string} nodeName The name of the nodeName
 * @param {string} appearance The name of the data conversion appearance. If you don't have your own put in "default".
 * @param {string} type The name of your hardware interface
**/
exports.addIO = function (objectName, nodeName, appearance, type) {
    utilities.createFolder(objectName, dirnameO, globalVariables.debug);

    var objectID = utilities.getObjectIdFromTarget(objectName, dirnameO);
    if (globalVariables.debug) console.log("AddIO objectID: " + objectID + "   " + type);

    //objID = nodeName + objectID;

    if (!_.isUndefined(objectID) && !_.isNull(objectID)) {

        if (objectID.length > 13) {

            if (globalVariables.debug) console.log("I will save: " + objectName + " and: " + nodeName);

            if (objects.hasOwnProperty(objectID)) {
                objects[objectID].developer = globalVariables.developer;
                objects[objectID].name = objectName;

                if (!objects[objectID].nodes.hasOwnProperty(nodeName)) {
                    var thisObject = objects[objectID].nodes[nodeName] = new Node();
                    thisObject.x = utilities.randomIntInc(0, 200) - 100;
                    thisObject.y = utilities.randomIntInc(0, 200) - 100;
                    thisObject.frameSizeX = 47;
                    thisObject.frameSizeY = 47;
                }



                var thisObj = objects[objectID].nodes[nodeName];
                thisObj.name = nodeName;
                thisObj.appearance = appearance;
                thisObj.type = type;

                //Add entries to the management data structures
                if(!hardwareInterfaces.hasOwnProperty(type)){
                    hardwareInterfaces[type] = new HardwareInterface();
                }
                
                if(!hardwareInterfaces[type].objects.hasOwnProperty(objectName)){
                    hardwareInterfaces[type].objects[objectName] = new HybridObject(objectName);
                }
               
                if(!hardwareInterfaces[type].objects[objectName].nodes.hasOwnProperty(nodeName)){
                    hardwareInterfaces[type].objects[objectName].nodes[nodeName] = new EmptyNode(nodeName);
                }
            }
        }
    }
    objectID = undefined;
};

exports.getObjectIdFromObjectName = function (objectName) {
   return utilities.getObjectIdFromTarget(objectName, dirnameO);
};

/**
 * @desc developerOn() Enables the developer mode for all HybridObjects and enables the developer web interface
**/
exports.developerOn = function () {
    globalVariables.developer = true;
    for (var objectID in objects) {
        objects[objectID].developer = true;
    }
};



/**
 * @desc getDebug() checks if debug mode is turned on
 * @return {boolean} true if debug mode is on, false otherwise
**/
exports.getDebug = function () {
    return globalVariables.debug;
};

/*
 ********** END API FUNCTIONS *********
 */


/**
 * @desc setup() DO NOT call this in your hardware interface. setup() is only called from server.js to pass through some global variables.
**/
exports.setup = function (objExp, objLookup, glblVars, dir, appearances, cb, objValue) {
    objects = objExp;
    objectLookup = objLookup;
    globalVariables = glblVars;
    dirnameO = dir;
    nodeAppearanceModules = appearances;
    callback = cb;
    Node = objValue;
};