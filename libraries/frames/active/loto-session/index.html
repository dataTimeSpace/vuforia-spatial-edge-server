<!DOCTYPE html>
<html lang="en">
<head>
    <script src="objectDefaultFiles/object.js"></script>
    <script src="objectDefaultFiles/pep.min.js"></script>
    <meta charset="UTF-8">
    <title>LOTO Session</title>
    <style>
        @font-face {
            font-family: 'Brutal Type';
            src: url('resources/brutal/BrutalType.otf');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'Brutal Type';
            src: url('resources/brutal/BrutalType-Bold.otf');
            font-weight: bold;
            font-style: normal;
        }
        body {
            font-family: "Brutal Type", "Helvetica Neue", Helvetica, Arial, sans-serif;
            /*border: 2px solid black;*/
        }
        .block {
            width: 200px;
            height: 200px;
            border: 10px solid white;
            color: white;
            background-color: rgba(0,0,0,0.7);
            position: absolute;
            margin: 0;
            padding: 0;
            text-align: center;
            line-height: 190px;
            font-size: 60px;
            box-sizing: border-box;
            border-radius: 5px;
        }
        .small {
            width: 120px;
            height: 120px;
            line-height: 120px;
        }
        .smaller {
            width: 80px;
            height: 80px;
            line-height: 80px;
            font-size: 20px;
        }
        .sleek {
            border-width: 0;
            color: white;
        }
        .dashedOutline {
            border: 3px dashed white;
            background-color: transparent;
        }
        .step {
            background-color: rgba(0,255,255,0.3);
            color: cyan;
            font-size: 45px;
            font-weight: bold;
            border: none;
        }
        .completed {
            background-color: rgba(0,255,0,0.3);
            color: rgb(0,255,0);
        }
        #instructionLabel {
            position: absolute;
            left: 0;
            top: 0;
            width: 768px;
            line-height: 80px;
            text-align: center;
            color: white;
            font-size: 20px;
        }
        
        #navigation {
            position: absolute;
            left: 0;
            top: 0;
        }
        #navArrow {
            position: absolute;
            left: 0;
            top: 0;
            width: 100px;
            height: 100px;
            border: 5px solid cyan;
        }
        #navCanvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 768px;
            height: 414px;
            pointer-events: none;
            background-color: transparent;
            /*border: 2px solid red;*/
        }
        .dangerWarningIcon {
            position: absolute;
            left: 100px;
            top: 5px;
            width: 70px;
            height: 70px;
        }
        #handle {
            width: 60px;
        }
        #handleDots {
            position: absolute;
            left: 5px; /* centered */
            top: 0;
            width: 50px;
            height: 200px;
        }
        
    </style>
</head>
<body style="margin: 0; width: 768px; height: 414px;">
    <div id="container"></div>
    <div id="navigation">
        <canvas id="navCanvas" width="768px" height="414px"></canvas>
    </div>
</body>
<script>
    
    var screenWidth = window.innerWidth; //768;
    var screenHeight = window.innerHeight;

    var InterfaceStates = Object.freeze({
        COLLAPSED: 0,
        EXPANDED_EDITABLE: 1,
        EXPANDED_PLAYBACK: 2
    });
    
    var stepIDs = [];

    var currentInterfaceState = InterfaceStates.COLLAPSED;
    
    var realityInterface = new RealityInterface();

    var container = document.getElementById('container');
    // var navigation = document.getElementById('navigation');
    
    var isSessionEditing = false;
    
    var framesCreatedDuringSession = {};
    
    var currentStepNumber = 0;
    var didManuallySetStepNumber = false;
    var manuallySetStepNumber = 0;

    var dangerTypes = {};
    var DangerTypes = Object.freeze({
        ELECTRIC: 0,
        WATER: 1,
        GAS: 2,
        PNEUMATIC: 3
    });

    var stepButtonWidth = 80;
    
    var stepNumberSelected;
    var stepDivSelected;
    var stepRenderingOrder;

    function getCurrentStepNumber() {
        if (didManuallySetStepNumber) { // when you tap on one of the step buttons, override the auto calculation
            return manuallySetStepNumber;
        }
        
        var firstUncompletedStep = null;
        stepIDs.forEach(function(id, index) {
            if (firstUncompletedStep) return; // only get the first one
            if (!framesCreatedDuringSession[id].isCompleted) {
                firstUncompletedStep = index+1;
            }
        });
        return firstUncompletedStep;
    }
    
    var stepStartPositionMap = {};
    
    function init() {
        renderInterfaceState(currentInterfaceState);
        console.log('W: ' + window.innerWidth + ', H: ' + window.innerHeight);

        realityInterface.enableCustomInteractionModeInverted();
        realityInterface.setMoveDelay(-1); // impossible to move/delete except using custom interaction div

        // this means another exclusiveFullscreen frame cannot coexist with this one
        realityInterface.setExclusiveFullScreenOn(function(fullScreenEjectedEvent) {
            // if another exclusive fullscreen frame kicks this one out of fullscreen, update the UI
            if (currentInterfaceState !== InterfaceStates.COLLAPSED) {
                currentInterfaceState = InterfaceStates.COLLAPSED;
                renderInterfaceState(currentInterfaceState);
            }
        }); 

        realityInterface.subscribeToFrameCreatedEvents(function(frameCreatedEvent) {
            console.log('inside frame: ' + frameCreatedEvent);
            if (isSessionEditing) {
                if (frameCreatedEvent.frameType === 'loto') {
                    if (!framesCreatedDuringSession.hasOwnProperty(frameCreatedEvent.frameId)) {
                        stepIDs.push(frameCreatedEvent.frameId);
                        
                        // TODO: I think this can be removed, the actual "step number" doesn't get used by loto step because it used dangerTypeNumber instead
                        function sendStepNumber(stepNumber) {
                            // send step number to each frame
                            realityInterface.sendMessageToFrame(frameCreatedEvent.frameId, {
                                messageFromLOTOSession: {
                                    stepNumber: stepNumber
                                }
                            });
                        }
                        
                        var stepNumberAtThisTime = stepIDs.length;
                        
                        // let the step frame load before sending message to it
                        // send 3 times over the course of 2 seconds
                        setTimeout(function() {
                            sendStepNumber(stepNumberAtThisTime);
                            setTimeout(function() {
                                sendStepNumber(stepNumberAtThisTime);
                                setTimeout(function() {
                                    sendStepNumber(stepNumberAtThisTime);
                                }, 1000);
                            }, 500);
                        }, 500);
                    }
                    framesCreatedDuringSession[frameCreatedEvent.frameId] = frameCreatedEvent;
                    framesCreatedDuringSession[frameCreatedEvent.frameId].stepNumber = stepNumberAtThisTime;
                    
                    saveSessionInfo();

                    renderInterfaceState(currentInterfaceState);
                }
            }
        });

        realityInterface.subscribeToFrameDeletedEvents(function(frameDeletedEvent) {
            console.log('inside frame: ' + frameDeletedEvent);
            if (frameDeletedEvent.frameType === 'loto') {
                if (framesCreatedDuringSession.hasOwnProperty(frameDeletedEvent.frameId)) {
                    var stepIndex = stepIDs.indexOf(frameDeletedEvent.frameId);
                    if (stepIndex > -1) {
                        stepIDs.splice(stepIndex, 1);
                    }

                    // decrease step number by 1 for anything higher than the one that was deleted
                    Object.keys(framesCreatedDuringSession).forEach(function(frameId) {
                        var info = framesCreatedDuringSession[frameId];
                        if (info.stepNumber > framesCreatedDuringSession[frameDeletedEvent.frameId].stepNumber) {
                           info.stepNumber -= 1;
                        }
                    });
                    
                    delete framesCreatedDuringSession[frameDeletedEvent.frameId];

                    recomputeDangerTypeNumbers();
                    saveSessionInfo();
                    renderInterfaceState(currentInterfaceState);
                }
            }
        });

        realityInterface.addFrameMessageListener(function(message) {

            var sourceFrame = message.sourceFrame;
            var messageFromLOTOStep = message.msgContent.messageFromLOTOStep;

            if (typeof messageFromLOTOStep !== 'undefined') {

                if (typeof messageFromLOTOStep.stepNumber !== 'undefined' && typeof messageFromLOTOStep.isCompleted !== 'undefined') {
                    if (framesCreatedDuringSession[sourceFrame]) {
                        if (messageFromLOTOStep.isCompleted && !framesCreatedDuringSession[sourceFrame].isCompleted) {
                            didManuallySetStepNumber = false;
                        }
                        framesCreatedDuringSession[sourceFrame].isCompleted = messageFromLOTOStep.isCompleted;
                        renderInterfaceState(currentInterfaceState);
                    }
                }
                
                if (typeof messageFromLOTOStep.stepNumber !== 'undefined' && typeof messageFromLOTOStep.screenPosition !== 'undefined') {
                    if (framesCreatedDuringSession[sourceFrame]) {
                        // console.log('got position from step ' + messageFromLOTOStep.stepNumber + ' but I am step ' + getCurrentStepNumber());
                        
                        if (messageFromLOTOStep.stepNumber === getCurrentStepNumber() && currentInterfaceState === InterfaceStates.EXPANDED_PLAYBACK) {
                            renderNavigationArrow(messageFromLOTOStep.screenPosition);
                        }

                    }
                }
                
                if (typeof messageFromLOTOStep.stepNumber !== 'undefined' && typeof messageFromLOTOStep.dangerType !== 'undefined') {
                    framesCreatedDuringSession[sourceFrame].dangerType = messageFromLOTOStep.dangerType;
                    recomputeDangerTypeNumbers();
                    saveSessionInfo();
                }
                
            }
        });

        realityInterface.addReadPublicDataListener('storage', 'sessionInfo', function (savedInfo) {
            loadSessionInfo(savedInfo);
        });
        
        // pointerevent listeners for re-ordering steps
        document.addEventListener('pointermove', onDocumentPointerMove);
        document.addEventListener('pointerup', onDocumentPointerUp);
    }
    init();
    
    function recomputeDangerTypeNumbers() {
        
        dangerTypes = {};
        
        var sortedFrameKeys = Object.keys(framesCreatedDuringSession).sort(function(frameIdA, frameIdB) {
            return framesCreatedDuringSession[frameIdA].stepNumber - framesCreatedDuringSession[frameIdB].stepNumber;
        });
        
        sortedFrameKeys.forEach(function(frameId) {
            var info = framesCreatedDuringSession[frameId];
            if (typeof info.dangerType !== 'undefined') {
                
                if (typeof dangerTypes[info.dangerType] === 'undefined') {
                    dangerTypes[info.dangerType] = [frameId];
                } else {
                    dangerTypes[info.dangerType].push(frameId);
                }
                
            }
        });
        
        // send a message to all framesCreatedDuringSession to update them with their new dangerTypeNumber
        for (var frameKey in framesCreatedDuringSession) {
            realityInterface.sendMessageToFrame(frameKey, {
                messageFromLOTOSession: {
                    dangerTypeNumber: getDangerTypeNumberForFrame(frameKey)
                }
            });
        }
    }
    
    function getDangerTypeNumberForFrame(frameId) {
        var info = framesCreatedDuringSession[frameId];

        if (typeof info.dangerType !== 'undefined') {
            return dangerTypes[info.dangerType].indexOf(frameId) + 1;
        }
        
        return 0;
    }

    function saveSessionInfo() {
        var sessionInfo = {
            stepIDs: stepIDs,
            framesCreatedDuringSession: framesCreatedDuringSession
        };
        console.log('saveSessionInfo', sessionInfo);
        realityInterface.writePublicData('storage', 'sessionInfo',  sessionInfo);
    }
    
    function loadSessionInfo(savedInfo) {
        stepIDs = savedInfo.stepIDs;
        framesCreatedDuringSession = savedInfo.framesCreatedDuringSession;
        setTimeout(function() {
            recomputeDangerTypeNumbers(); // want to make sure the loto step frames have actually loaded so they'll receive these messages
        }, 1000);
        renderInterfaceState(currentInterfaceState);
    }

    // adjust positions based on real width and height of the device
    function adjustUIForFrameDimensions() {
        
        realityInterface.getScreenDimensions(function(width, height) {
            screenWidth = width;
            screenHeight = height;

            document.body.style.width = screenWidth;
            document.body.style.height = screenHeight;

            var navCanvas = document.getElementById('navCanvas');
            if (navCanvas) {
                navCanvas.style.width = screenWidth + 'px';
                navCanvas.style.height = screenHeight + 'px';
                navCanvas.width = screenWidth;
                navCanvas.height = screenHeight;
            }

            var instructionLabel = document.getElementById('instructionLabel');
            if (instructionLabel) {
                instructionLabel.style.width = screenWidth + 'px';
            }
        });
        

    }
    
    function renderNavigationArrow(screenPosition) {
        // create / show arrow if hidden
        // var arrow = createDiv('navArrow', null, null, navigation);
        // arrow.style.left = screenPosition.upperLeft.x + 'px';
        // arrow.style.top = screenPosition.upperLeft.y + 'px';
        
        var lowerLeft = {
            x: screenPosition.center.x,
            y: screenPosition.center.y
        };
        
        var canvas = document.getElementById('navCanvas');
        var ctx = canvas.getContext('2d');
        
        ctx.clearRect(0,0,screenWidth,screenHeight);
        
        var startX = getArrowStartX(getCurrentStepNumber()); //768/2; // TODO: get position of step number
        var startY = screenHeight - 100;
        
        if (lowerLeft.y > startY) { return; } // don't draw a line down, it looks weird

        // starting path of the arrow from the start square to the end square and drawing the stroke
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(startX, lowerLeft.y);
        ctx.lineTo(lowerLeft.x, lowerLeft.y);
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 5;
        ctx.stroke();
    }
    
    function getArrowStartX(stepNumber) {
        return stepStartPositionMap[stepNumber] || screenWidth/2; // use center of screen as backup
    }

    function renderInterfaceState(state) {

        console.log('rendering interface state: ' + interfaceStateToString(state));

        // clear the canvas
        var canvas = document.getElementById('navCanvas');
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,screenWidth,screenHeight);

        // remove or hide all previous contents of container
        var first = container.firstElementChild;
        while (first) {
            first.remove();
            first = container.firstElementChild;
        }

        if (state === InterfaceStates.COLLAPSED) {
            
            var handle = createDiv('handle', ['block', 'sleek'], null, container);
            var handleDots = document.createElement('img');
            handleDots.id = 'handleDots';
            handleDots.src = 'resources/handle-dots.svg';
            handle.appendChild(handleDots);

            // this can also be done without the API by manually giving these divs the class 'realityInteraction'
            realityInterface.setInteractableDivs([handle, handleDots]);

            var editButton = createDiv('editButton', ['block', 'sleek'], 'Edit LOTO Steps', container);
            editButton.style.left = '70px';
            editButton.style.width = '698px';

            editButton.addEventListener('pointerdown', function(e) {
                // reset completion state when you edit
                for (var frameKey in framesCreatedDuringSession) {
                    framesCreatedDuringSession[frameKey].isCompleted = false;
                }
                
                currentInterfaceState = InterfaceStates.EXPANDED_EDITABLE;
                renderInterfaceState(currentInterfaceState);
            });

            if (Object.keys(framesCreatedDuringSession).length > 0) {
                var playButton = createDiv('playButton', ['block', 'sleek'], 'Start Procedure', container);
                playButton.style.left = '70px';
                playButton.style.width = '698px';
                playButton.style.top = '220px';
                playButton.addEventListener('pointerdown', function(e) {
                    // reset completion state when you play again
                    for (var frameKey in framesCreatedDuringSession) {
                        framesCreatedDuringSession[frameKey].isCompleted = false;
                    }
                    
                    currentInterfaceState = InterfaceStates.EXPANDED_PLAYBACK;
                    renderInterfaceState(currentInterfaceState);
                });
            }
            
            realityInterface.setFullScreenOff();
            isSessionEditing = false;
            
            // send a message to all framesCreatedDuringSession to hide them
            for (var frameKey in framesCreatedDuringSession) {
                realityInterface.sendMessageToFrame(frameKey, {
                    messageFromLOTOSession: {
                        hideFrame: true
                    }
                });
            }
            
        } else if (state === InterfaceStates.EXPANDED_EDITABLE) {

            createDiv('instructionLabel', null, 'Add LOTO Steps...', container);

            renderExpanded();

            isSessionEditing = true;
            
            // send a message to all framesCreatedDuringSession to show them if they are hidden
            for (var frameKey in framesCreatedDuringSession) {
                realityInterface.sendMessageToFrame(frameKey, {
                    messageFromLOTOSession: {
                        hideFrame: false,
                        isEditable: true
                    }
                });
            }
            
            // add touch down / move / up handlers for each step 
            
            [].slice.call(document.querySelectorAll('.step')).forEach(function(stepButton, index) {
                stepButton.addEventListener('pointerdown', function(e) {
                    stepNumberSelected = parseInt(stepButton.getAttribute("data-step-number"));
                    stepDivSelected = stepButton;
                    console.log('pointerdown on step ' + stepNumberSelected);
                });
            });

        } else if (state === InterfaceStates.EXPANDED_PLAYBACK) {
            
            renderExpanded();
            
            // render warning divs in corner based on overall dangers of the session/sequence
            var iconIndex = 0;
            for (var dangerType in dangerTypes) {
                var warning = document.createElement('img');
                warning.id = 'dangerWarning' + dangerType;
                warning.className = 'dangerWarningIcon';
                warning.src = getDangerTypeWarningIconSrc(parseInt(dangerType));
                warning.style.left = 100 + (iconIndex * 80) + 'px';
                container.appendChild(warning);
                iconIndex++;
            }
            
            isSessionEditing = false;

            // send a message to all framesCreatedDuringSession to show them if they are hidden
            for (var frameKey in framesCreatedDuringSession) {
                realityInterface.sendMessageToFrame(frameKey, {
                    messageFromLOTOSession: {
                        hideFrame: false,
                        isEditable: false
                    }
                });
            }
            
            if (currentStepNumber !== getCurrentStepNumber()) {
                
                // collapse previous step
                collapseStep(currentStepNumber);
                console.log('render new step (was on ' + currentStepNumber + ' but now on ' + getCurrentStepNumber());
                currentStepNumber = getCurrentStepNumber();
                // show new step
                expandStep(currentStepNumber);
                
            }
            
        }
        
        function expandStep(stepNumber) {
            console.log('expand step ' + stepNumber);
            setTimeout(function() {
                realityInterface.sendMessageToFrame(stepIDs[stepNumber-1], {
                    messageFromLOTOSession: {
                        expandFrame: true,
                        isEditable: false
                    }
                });
            }, 200);
        }
        
        function collapseStep(stepNumber) {
            console.log('collapse step ' + stepNumber);
            setTimeout(function() {
                realityInterface.sendMessageToFrame(stepIDs[stepNumber - 1], {
                    messageFromLOTOSession: {
                        expandFrame: false,
                        isEditable: false
                    }
                });
            }, 100);
        }
        
        function renderExpanded() {

            stepIDs = Object.keys(framesCreatedDuringSession);
            
            var doneButton = createDiv('editButton', ['block', 'smaller', 'sleek'], 'Done', container);

            var areAllCompleted = true;
            stepIDs.forEach(function(id) {
                if (!framesCreatedDuringSession[id].isCompleted) {
                    areAllCompleted = false;
                }
            });
            if (stepIDs.length === 0) {
                areAllCompleted = false;
            }
            
            if (areAllCompleted) {
                doneButton.classList.add('completed');
            }
            
            doneButton.addEventListener('pointerdown', function(e) {
                currentInterfaceState = InterfaceStates.COLLAPSED;
                renderInterfaceState(currentInterfaceState);
            });
            
            // var showNextStepButton = false;
            var margin = 10;
            var stepButtonTop = (screenHeight - stepButtonWidth - margin);

            var numSteps = stepIDs.length;

            // if (showNextStepButton) {
            //     numSteps++;
            // }

            stepStartPositionMap = {};

            stepIDs.forEach(function(id, index) {
                var stepNumber = index + 1;
                var stepButton = createDiv('stepButton' + stepNumber, ['block', 'smaller', 'step'], stepNumber, container);
                stepButton.setAttribute("data-step-number", stepNumber);
                stepButton.style.left = screenWidth/2 - ((stepButtonWidth + margin)/2) * numSteps + (stepButtonWidth + margin) * index + 'px';
                stepStartPositionMap[stepNumber] = parseInt(stepButton.style.left) + stepButton.getClientRects()[0].width/2;
                stepButton.style.top = stepButtonTop + 'px';
                
                if (framesCreatedDuringSession[id].isCompleted) {
                    stepButton.classList.add('completed');
                }
                
                stepButton.addEventListener('pointerdown', function(e) {
                    
                    if (!isSessionEditing) {
                        manuallySetStepNumber = stepNumber;
                        didManuallySetStepNumber = true;
                        renderInterfaceState(currentInterfaceState);
                    }

                });
                
            });

            // if (showNextStepButton) {
            //     var nextStepButton = createDiv('nextStepButton', ['block', 'smaller', 'dashedOutline'], '+', container);
            //     nextStepButton.style.left = screenWidth/2 - ((stepButtonWidth + margin)/2) * numSteps + (stepButtonWidth + margin) * (numSteps-1) + 'px';
            //     nextStepButton.style.top = stepButtonTop + 'px';
            // }

            if (!realityObject.sendFullScreen) {
                realityInterface.setStickyFullScreenOn();
            }
        }
        
        // after the correct elements have been added for this state, adjust positions based on real size of the device
        adjustUIForFrameDimensions();
    }
    
    function onDocumentPointerMove(e) {
        if (isSessionEditing && stepDivSelected) {
            var newLeft = (e.pageX - stepButtonWidth/2);
            stepDivSelected.style.left = newLeft + 'px';
            
            // whenever you cross the threshold so that this is < x of the thing before it, or > x of the thing after it
            // animate moving the other one into this one's current spot
            
            // gets the X positions of each button, including the one dragged around, and sorts the list
            var positions = [].slice.call(document.querySelectorAll('.step')).filter(function(stepDiv) {
                return parseInt(stepDiv.getAttribute('data-step-number')) !== stepNumberSelected;
            }).map(function(stepDiv) {
                return stepStartPositionMap[parseInt(stepDiv.getAttribute('data-step-number'))];
            });
            positions.push(e.pageX);
            positions.sort();
            
            function getKeyByValue(object, value) {
                return Object.keys(object).find(function(key) {
                    return object[key] === value;
                });
            }
            
            // figures out which step number corresponds to which index of the sorted list of x positions
            stepRenderingOrder = positions.map(function(x) {
                var stepNumber = getKeyByValue(stepStartPositionMap, x);
                if (typeof stepNumber === 'undefined') {
                    stepNumber = stepNumberSelected;
                }
                return parseInt(stepNumber);
            });
            
            // renders the buttons based on their index in the stepRenderingOrder list
            stepRenderingOrder.forEach(function(stepNumber, index) {
                // render the button for stepNumber at x position for index (except for stepNumberSelected)
                if (stepNumber !== stepNumberSelected) {
                    var stepButton = document.getElementById('stepButton' + stepNumber);
                    stepButton.style.left = stepStartPositionMap[index+1] - stepButton.getClientRects()[0].width/2 + 'px';
                }
            });

        }
    }
    
    function onDocumentPointerUp(e) {
        if (isSessionEditing && stepDivSelected) {
            // var thisStepNumber = parseInt(stepButton.getAttribute("data-step-number"));
            // console.log('pointerup on step ' + thisStepNumber);
            
            // TODO: change step order in stepIDs, recompute dangerTypeNumbers (same as when you delete a step)
            
            if (stepRenderingOrder) {
                // determine which old steps became which new steps
                
                var previousStepMap = {};
                
                // create a previousMap of stepNumber: frameId
                Object.keys(framesCreatedDuringSession).forEach(function(frameId) {
                    var frameInfo = framesCreatedDuringSession[frameId];
                    var previousStepNumber = frameInfo.stepNumber;
                    previousStepMap[previousStepNumber] = frameId;
                });
                
                console.log('old', previousStepMap);

                // for each oldStepNumber, change the framesCreatedDuringSession[previousStepMap[oldStepNumber].frameId].stepNumber = newStepNumber

                // framesCreatedDuringSession[frameCreatedEvent.frameId].stepNumber = stepNumberAtThisTime;


                [].slice.call(document.querySelectorAll('.step')).map(function(stepDiv) {
                    return parseInt(stepDiv.getAttribute('data-step-number'));
                }).forEach(function(stepNumber) {
                    var newStepNumber = stepRenderingOrder.indexOf(stepNumber) + 1;
                    if (stepNumber !== newStepNumber) {
                        console.log('step number ' + stepNumber + ' became ' + newStepNumber);

                        framesCreatedDuringSession[previousStepMap[stepNumber]].stepNumber = newStepNumber;
                        
                    } else {
                        console.log('step number ' + stepNumber + ' is unchanged');
                    }
                });


                var newStepMap = {};
                Object.keys(framesCreatedDuringSession).forEach(function(frameId) {
                    var frameInfo = framesCreatedDuringSession[frameId];
                    var newStepNumber = frameInfo.stepNumber;
                    newStepMap[newStepNumber] = frameId;
                });

                console.log('new', newStepMap);
                
                recomputeDangerTypeNumbers();
            }

            stepRenderingOrder = null;
            stepNumberSelected = undefined;
            stepDivSelected = null;
            renderInterfaceState(currentInterfaceState);
        }
    }
    
    //
    // stepButton.addEventListener('pointermove', function(e) {
    //     var thisStepNumber = parseInt(stepButton.getAttribute("data-step-number"));
    //     console.log('pointermove on step ' + thisStepNumber);
    //
    //     if (thisStepNumber === stepNumberSelected) {
    //         stepDivSelected.style.left = (e.pageX - stepButtonWidth/2) + 'px';
    //     }
    // });
    //
    // stepButton.addEventListener('pointerup', function(e) {
    //     var thisStepNumber = parseInt(stepButton.getAttribute("data-step-number"));
    //     console.log('pointerup on step ' + thisStepNumber);
    //
    //     stepNumberSelected = undefined;
    //     stepDivSelected = null;
    //
    //     renderInterfaceState(currentInterfaceState);
    // });

    function interfaceStateToString(state) {
        return Object.keys(InterfaceStates)[state]; // this only works because the value of each key was set to be its index
    }

    function getDangerTypeWarningIconSrc(type) {
        if (type === DangerTypes.ELECTRIC) {
            return 'resources/loto-warnings/warning-electrical.svg';
        } else if (type === DangerTypes.WATER) {
            return 'resources/loto-warnings/warning-water.svg';
        } else if (type === DangerTypes.GAS) {
            return 'resources/loto-warnings/warning-pneumatic.svg';
        } else if (type === DangerTypes.PNEUMATIC) {
            return 'resources/loto-warnings/warning-mechanical.svg';
        } else return null;
    }
    
    /**
     * Shortcut for creating a div with certain style and contents, and possibly adding to a parent element
     * Any parameter can be omitted (pass in null) to ignore those effects
     * @param {string|null} id
     * @param {string|Array.<string>|null} classList
     * @param {string|null} innerHTML
     * @param {HTMLElement|null} parentToAddTo
     * @return {HTMLDivElement}
     */
    function createDiv(id, classList, innerHTML, parentToAddTo) {
        var preExistingDiv = document.getElementById(id);
        var div = preExistingDiv ? preExistingDiv : document.createElement('div');
        if (id) {
            div.id = id;
        }
        if (classList) {
            if (typeof classList === 'string') {
                div.className = classList;
            } else if (typeof classList === 'object') {
                classList.forEach(function(className) {
                    div.classList.add(className);
                });
            }
        }
        if (innerHTML) {
            div.innerHTML = innerHTML;
        }
        if (parentToAddTo) {
            parentToAddTo.appendChild(div);
        }
        return div;
    }
</script>
</html>
