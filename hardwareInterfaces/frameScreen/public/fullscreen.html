<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Frame Screen</title>
    <link rel="stylesheet" type="text/css" href="index.css">
    <style>
        .screenFrame {
            display: inline;
            /*opacity: 1.0;*/
        }

        .arFrame {
            display: none;
            /*opacity: 0.1;*/
        }
        body, html {
            height: 100%;
            margin: 0;
        }

        .bg {
            /* The image used */
            background-image: url("resources/frameScreen.jpg");

            /* Full height */
            height: 100%;

            /* Center and scale the image nicely */
            background-position: center;
            background-repeat: no-repeat;
            background-size: cover;
        }
    </style>
</head>
<body>

<div class="bg"></div>

<script src="/socket.io/socket.io.js"></script>

<script>

    var SERVER_IP = '192.168.56.7'; //'10.0.0.245'; //'10.68.23.38';
    var SERVER_PORT = '8080';

    // var OBJECT_NAME = 'frameScreen';
    var OBJECT_ID = 'frameScreenkz1hpiyymp4c';
    var frames = {};

    var marker = document.querySelector('.paletteMarker');
    var socket = io();

    var AR_MARKER_SIZE = 300.0;

    // constants
    var defaultValue = 0.00;

    // variables for drag interface
    var currentlyDraggedPanel = null;
    var dragOffsetX = 0;
    var dragOffsetY = 0;

    var mostRecentZ;
    var startDragZ;
    var DEFAULT_START_DRAG_Z = 500;

    // variables for screen <-> AR transition
    var arFrameState = {
        flipThreshold: 300,
        x: 0,
        y: 0,
        isInScreen: true
    };

    var clickAvailable = true;

    window.requestAnimFrame = function(){
        return (
            window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame     ||
            function(/* function */ callback){
                window.setTimeout(callback, 1000 / 60);
            }
        );
    }();

    function reloadFrames() {
        console.log('reload frames');
        var urlEndpoint = 'http://' + SERVER_IP + ':' + SERVER_PORT + '/object/' + OBJECT_ID;
        getData(OBJECT_ID, null, null, urlEndpoint, function (objectKey, frameKey, nodeKey, res) {
            console.log('got them!');
            console.log(objectKey, frameKey, nodeKey, res);
            frames = res.frames;

            // for (var frameKey in frames) {
            //     if (!frames.hasOwnProperty(frameKey)) continue;
            //     var thisFrame = frames[frameKey];
            //     if (!thisFrame.hasOwnProperty('width')) {
            //         thisFrame.width = 300;
            //     }
            //     if (!thisFrame.hasOwnProperty('height')) {
            //         thisFrame.height = 200;
            //     }
            // }

            // // filter out
            // for (var frameKey in frames) {
            //     if (!frames.hasOwnProperty(frameKey)) continue;
            //     if (typeof frames[frameKey].type === 'undefined') {
            //         delete frames[frameKey];
            //     }
            // }

            renderFrames();
        });
    }

    function getData(objectKey, frameKey, nodeKey, url, callback) {
        if (!nodeKey) nodeKey = null;
        if (!frameKey) frameKey = null;
        var _this = this;
        var req = new XMLHttpRequest();
        try {
            console.log('making GET request to ' + url);
            req.open('GET', url, true);
            // Just like regular ol' XHR
            req.onreadystatechange = function () {
                if (req.readyState === 4) {
                    if (req.status === 200) {
                        // JSON.parse(req.responseText) etc.
                        if (req.responseText)
                            callback(objectKey, frameKey, nodeKey, JSON.parse(req.responseText));
                    } else {
                        // Handle error case
                        console.log("could not load content");
                        _this.cout("could not load content");
                    }
                }
            };
            req.send();

        }
        catch (e) {
            this.cout("could not connect to" + url);
        }
    }

    /**
     * POST data as json to url, calling callback with the
     * JSON-encoded response data when finished
     * @param {String} url
     * @param {Object} body
     * @param {Function<Error, Object>} callback
     */
    function postData (url, body, callback) {
        var request = new XMLHttpRequest();
        var params = JSON.stringify(body);
        request.open('POST', url, true);
        request.onreadystatechange = function () {
            if (request.readyState !== 4) {
                return;
            }
            if (!callback) {
                return;
            }

            if (request.status === 200) {
                try {
                    callback(null, JSON.parse(request.responseText));
                } catch (e) {
                    callback({status: request.status, error: e, failure: true}, null);
                }
                return;
            }

            callback({status: request.status, failure: true}, null);
        };

        request.setRequestHeader("Content-type", "application/json");
        //request.setRequestHeader("Content-length", params.length);
        // request.setRequestHeader("Connection", "close");
        request.send(params);
    }

    function renderFrames() {
        // console.log('renderFrames');
        for (var frameKey in frames) {
            if (!frames.hasOwnProperty(frameKey)) continue;
            var frame = frames[frameKey];
            if (typeof frame.type === 'undefined') continue;

            addElement(frameKey, frame);
            drawTransformed(frameKey, frame);
        }

        requestAnimFrame(renderFrames);
    }

    function addElement(frameKey, frame) {
        var iframeId = "iframe" + frameKey;
        var iframeExists = document.querySelectorAll('#'+iframeId).length > 0;

        if (!iframeExists) {

            if (!frame.hasOwnProperty('width')) {
                frame.width = 300;
            }
            if (!frame.hasOwnProperty('height')) {
                frame.height = 200;
            }

            var scaleFactor = getScreenScaleFactor();
            var screenFrameWidth = frame.width / scaleFactor;
            var screenFrameHeight = frame.height / scaleFactor;

            var addContainer = document.createElement('div');
            addContainer.id = "object" + frameKey;
            // addContainer.className = "main";
            addContainer.classList.add('main', 'arFrame');
            // addContainer.style.display = "none";
            addContainer.style.border = 0;
            addContainer.style.position = 'absolute';
            var screenPos = getScreenPosFromARPos(frame.screen.x, frame.screen.y);
            addContainer.style.left = screenPos.x + "px"; //frame.screen.x + "px";
            addContainer.style.top = screenPos.y + "px"; //frame.screen.y + "px";

            var addIframe = document.createElement('iframe');
            addIframe.id = iframeId;
            addIframe.classList.add('main', 'frame');
            addIframe.frameBorder = 0;
            addIframe.style.width = (screenFrameWidth || 0) + "px";
            addIframe.style.height = (screenFrameHeight || 0) + "px";
            addIframe.style.visibility = "visible";
            // addIframe.style.pointerEvents = 'none';
            addIframe.src = 'http://' + SERVER_IP + ':' + SERVER_PORT + '/frames/' + frame.type + '.html';
            // addIframe.src = '/frames/' + frame.type + '.html';
            addIframe.dataset.nodeKey = null;
            addIframe.dataset.frameKey = frameKey;
            addIframe.dataset.objectKey = frame.objectId;
            addIframe.setAttribute("onload", 'onElementLoad(\"' + OBJECT_ID + '\",\"' + frameKey + '\")');
            addIframe.setAttribute("sandbox", "allow-forms allow-pointer-lock allow-same-origin allow-scripts");
            document.body.appendChild(addIframe);
            addIframe.display = 'inline';

            // add a cover object for touch event synthesizing
            var cover = document.createElement('div');
            cover.classList.add('main');
            cover.style.visibility = 'visible';
            cover.style.width = addIframe.style.width;
            cover.style.height = addIframe.style.height;
            cover.style.top = 0;
            cover.style.left = 0;
            cover.style.position = 'absolute';
            frame.frameTouchSynthesizer = new FrameTouchSynthesizer(cover, addIframe);

            document.body.appendChild(addContainer);
            addContainer.appendChild(addIframe);
            addContainer.appendChild(cover);
        }
    }

    function onElementLoad (objectKey, frameKey) {
        console.log('onElementLoad ' + objectKey + ' ' + frameKey);

        var newStyle = {
            object: objectKey,
            frame: frameKey,
            objectData: {
                ip: SERVER_IP
            },
            node: null,
            nodes: null,
            interface: null
        };
        var thisIframe = document.querySelector("#iframe" + frameKey);
        thisIframe._loaded = true;
        thisIframe.contentWindow.postMessage(JSON.stringify(newStyle), '*');
        thisIframe.contentWindow.postMessage(JSON.stringify({
            resizeFrameData: {
                width: parseInt(thisIframe.style.width),
                height: parseInt(thisIframe.style.height)
            }
        }), '*');


        console.log("on_load");
    }

    function drawTransformed(frameKey, frame) {
        var frameContainerDom = document.querySelector('#object'+frameKey);
        if (frame.visualization === 'screen') {
            // frameContainerDom.style.display = 'inline';
            frameContainerDom.classList.remove('arFrame');
            frameContainerDom.classList.add('screenFrame');
            frameContainerDom.style.left = frame.screen.x + 'px';
            frameContainerDom.style.top = frame.screen.y + 'px';
        } else {
            // frameContainerDom.style.display = 'none';
            frameContainerDom.classList.remove('screenFrame');
            frameContainerDom.classList.add('arFrame');
            var arPos = getARPosFromScreenPos(frame.screen.x, frame.screen.y);
            frameContainerDom.style.left = arPos.x + 'px';
            frameContainerDom.style.top = arPos.y + 'px';
        }
    }

    function getScreenFrames() {
        var screenFrames = [];
        for (var frameKey in frames) {
            if (!frames.hasOwnProperty(frameKey)) continue;
            if (frames[frameKey].visualization === 'screen') {
                screenFrames.push(frames[frameKey]);
            }
        }
        return screenFrames;
    }

    function getARFrames() {
        var arFrames = [];
        for (var frameKey in frames) {
            if (!frames.hasOwnProperty(frameKey)) continue;
            if (frames[frameKey].visualization === 'ar') {
                arFrames.push(frames[frameKey]);
            }
        }
        return arFrames;
    }

    function getFrameKey(frame) {
        return frame.uuid || frame.objectId + frame.name;
    }

    function getMarkerRect() {
        var windowWidth = window.innerWidth;
        var windowHeight = window.innerHeight;

        var markerWidth = 600;
        var markerHeight = 600;

        var rect = {
            x: (windowWidth/2 - markerWidth/2),
            y: (windowHeight/2 - markerHeight/2),
            width: markerWidth,
            height: markerHeight
        };

        return rect;
    }

    /**
     * Utility for getting scale factor between screen coordinates and AR marker coordinates.
     * @return {number} scale factor. 1 means they are the same and 0.5 means marker in AR is half as big as marker on screen.
     */
    function getScreenScaleFactor() {
        var markerRect = getMarkerRect();
        return AR_MARKER_SIZE / markerRect.height;
    }

    /**
     * Utility for converting coordinates from AR space to screen space.
     * @param {number} arX - x coordinate in AR space relative to center of marker.
     * @param {number} arY - y coordinate in AR space relative to center of marker.
     * @return {{x: number, y: number}}
     */
    function getScreenPosFromARPos(arX, arY) {
        var markerRect = getMarkerRect();
        var scaleFactor = getScreenScaleFactor();
        var screenX = (markerRect.x + markerRect.width/2) + (arX / scaleFactor);
        var screenY = (markerRect.y + markerRect.height/2) + (arY / scaleFactor);
        return {
            x: screenX,
            y: screenY
        };
    }

    /**
     * Utility for converting coordinates from screen space to AR space.
     * @param {number} screenX - x coordinate relative to upper left of screen.
     * @param {number} screenY - y coordinate relative to upper left of screen.
     * @return {{x: number, y: number}}
     */
    function getARPosFromScreenPos(screenX, screenY) {
        var markerRect = getMarkerRect();
        var scaleFactor = getScreenScaleFactor();
        var arX = (screenX - (markerRect.x + markerRect.width/2)) * scaleFactor;
        var arY = (screenY - (markerRect.y + markerRect.height/2)) * scaleFactor;
        return {
            x: arX,
            y: arY
        };
    }

    window.onload = function() {
        initializeDragInterface();
        reloadFrames();

        // createButton.onclick = function(event) {
        //     console.log('create frame');
        //     var frameData = {
        //         src: 'gauge'
        //     };
        //     socket.emit('createFrame', frameData);
        // };

        socket.on('screenObject', function(msg) {
            // console.log(msg);
            var screenPos = getScreenPosFromARPos(msg.x, msg.y);
            // console.log(screenPos.x + ', ' + screenPos.y);

            if (msg.touchState === 'touchstart') {
                if (msg.object && msg.frame) {
                    console.log('dont move frame!', msg.object, msg.frame);

                    currentlyDraggedPanel = document.querySelector('#iframe' + msg.frame);
                    console.log('virtually set currentlyDraggedPanel to ', currentlyDraggedPanel);
                    // if (currentlyDraggedPanel) {
                    //     var frame = frames[currentlyDraggedPanel.dataset.frameKey];
                    //     frame.screen.x = mouseX + dragOffsetX;
                    //     frame.screen.y = mouseY + dragOffsetY;
                    // }

                } else {
                    simulateMouseEvent(screenPos.x, screenPos.y, 'mouseup');
                    simulateMouseEvent(screenPos.x, screenPos.y, 'mousedown');
                }

            } else if (msg.touchState === 'touchmove') {
                simulateMouseEvent(screenPos.x, screenPos.y, 'mousemove');
                clickAvailable = true;

            } else if (msg.touchState === null) {
                simulateMouseEvent(screenPos.x, screenPos.y, 'mouseup');

            }

            if (msg.object && msg.frame) {
                // console.log('set visibility: ' + msg.isScreenVisible + ' for object ' + msg.object + ', frame ' + msg.frame);
                var frame = frames[msg.frame];
                frame.visualization = msg.isScreenVisible ? 'screen' : 'ar';
            }

        });

        socket.on('frameDataCallback', function(frame) {
            console.log('frameDataCallback', frame);
            var frameKey = getFrameKey(frame);
            frames[frameKey] = frame;
        });

    };

    function simulateMouseEvent(x,y,eventName) {
        mouseX = x;// * 2.0;
        mouseY = y;// * 2.0;

        var ev = new MouseEvent(eventName, {
            'view': window,
            'bubbles': true,
            'cancelable': true,
            'screenX': x,
            'screenY': y
        });
        ev.simulated = true;

        // el is null if x,y is outside window boundaries
        var el = document.elementFromPoint(x, y);
        if (el) {
            if (el.tagName === 'BUTTON' && eventName === 'mousedown' && clickAvailable) {
                el.click();
                clickAvailable = false;
            }
            el.dispatchEvent(ev);
        }
    }

    function initializeDragInterface() {

        var timer;
        var clickedPanelContainer = null;

        // add event listeners for mouse down, up, move, (cancel?)

        document.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
//        document.addEventListener('mouseout', onMouseUpdate, false);

        var interactionState = getStates().NONE;

        function onMouseDown(e) {
            console.log("mousedown", interactionState);
            interactionState = performAction(getActions().MOUSE_DOWN, interactionState);
        }

        function onMouseMove(e) {
            // console.log("mousemove", interactionState);

            // remote touch came from phone
            if (e.simulated) {
                mouseX = e.screenX;// * 2.0;
                mouseY = e.screenY;// * 2.0;
            } else {
                mouseX = e.pageX;
                mouseY = e.pageY;
            }

            interactionState = performAction(getActions().MOUSE_MOVE, interactionState);

            // console.log(currentlyDraggedPanel);
            // if (currentlyDraggedPanel) {
            //     currentlyDraggedPanel.style.top = mouseY + dragOffsetY + "px"; // + 20
            //     currentlyDraggedPanel.style.left = mouseX + dragOffsetX + "px"; // + 20
            // }

            if (currentlyDraggedPanel) {
                var frame = frames[currentlyDraggedPanel.dataset.frameKey];
                frame.screen.x = mouseX + dragOffsetX;
                frame.screen.y = mouseY + dragOffsetY;
            }
        }

        function onMouseUp(e) {
            console.log("mouseup", interactionState);
            interactionState = performAction(getActions().MOUSE_UP, interactionState);
        }

        // maintain a state machine that triggers actions upon entering each state

        function getStates() {
            return {
                NONE: 0,
                CLICK: 1,
                HOLD: 3,
                DRAG: 5
            };
        }

        function getActions() {
            return {
                NONE: 0,
                MOUSE_DOWN: 1,
                MOUSE_MOVE: 2,
                MOUSE_UP: 3,
                MOUSE_CANCEL: 4,
                TIME_PASSED: 5
            };
        }

        function getEvents() {
            return {
                MOUSE_START_CLICK: 0,
                MOUSE_STOP_CLICK: 1,
                MOUSE_START_HOLD: 2,
                MOUSE_STOP_HOLD: 3,
                MOUSE_START_DRAG: 4,
                MOUSE_STOP_DRAG: 5
            };
        }

        function performAction(action, currentState) {

            if (action === getActions().MOUSE_DOWN) {
                if (currentState === getStates().NONE) {
                    triggerEvent(getEvents().MOUSE_START_CLICK);
                    return getStates().CLICK;
                }

            } else if (action === getActions().TIME_PASSED) {
                if (currentState === getStates().CLICK) {
                    triggerEvent(getEvents().MOUSE_START_HOLD);
                    return getStates().HOLD;
                }

            } else if (action === getActions().MOUSE_MOVE) {
                if (currentState === getStates().CLICK || currentState === getStates().HOLD) {
                    triggerEvent(getEvents().MOUSE_START_DRAG);
                    return getStates().DRAG;
                }

            } else if (action === getActions().MOUSE_UP || action === getActions().MOUSE_CANCEL) {
                if (currentState === getStates().CLICK) {
                    triggerEvent(getEvents().MOUSE_STOP_CLICK)
                } else if (currentState === getStates().HOLD) {
                    triggerEvent(getEvents().MOUSE_START_HOLD);
                } else if (currentState === getStates().DRAG) {
                    triggerEvent(getEvents().MOUSE_STOP_DRAG);
                }

                return getStates().NONE;

            }
            return currentState;
        }

        function triggerEvent(event) {
            clearTimeout(timer);
            switch (event) {
                case getEvents().MOUSE_START_CLICK:
                    startClick();
                    timer = setTimeout(function(){
                        interactionState = performAction(getActions().TIME_PASSED, interactionState);
                    }, 1000);
                    break;
                case getEvents().MOUSE_START_HOLD:
                    startHoldOrDrag();
                    break;
                case getEvents().MOUSE_START_DRAG:
                    startHoldOrDrag();
                    break;
                case getEvents().MOUSE_STOP_CLICK:
                    stopClick();
                    break;
                case getEvents().MOUSE_STOP_HOLD:
                case getEvents().MOUSE_STOP_DRAG:
                    stopHoldOrDrag();
                    break;
                default:
                    console.log("shouldn't happen");
            }
        }

        function isDraggableElement(clickedElement) {
            return clickedElement.classList.contains('frame');
        }

        function startClick() {
            clickedPanelContainer = null;
            var allDivsHere = getAllDivsUnderCoordinate(mouseX, mouseY);
            allDivsHere.some( function(clickedElement) {
                if (isDraggableElement(clickedElement)) {
                    clickedPanelContainer = clickedElement;
                    dragOffsetX = clickedPanelContainer.getBoundingClientRect().x - mouseX;
                    dragOffsetY = clickedPanelContainer.getBoundingClientRect().y - mouseY;
                }
                return (!!clickedPanelContainer);
            });
        }

        function stopClick() {
            // console.log('clicked on frame');
            // console.log(clickedPanelContainer);
        }

        function startHoldOrDrag() {
            if (!currentlyDraggedPanel && clickedPanelContainer) {
                currentlyDraggedPanel = clickedPanelContainer;

                // console.log('socket emit ', {objectKey: OBJECT_ID, frameKey: currentlyDraggedPanel.id, nodeKey: null});
                socket.emit('writeScreenObject', {objectKey: currentlyDraggedPanel.dataset.objectKey, frameKey: currentlyDraggedPanel.dataset.frameKey, nodeKey: currentlyDraggedPanel.dataset.nodeKey});
                console.log('writeScreenObject');

                clickedPanelContainer = null;
            }
        }

        function stopHoldOrDrag() {
            // if (currentlyDraggedPanel) {
            //     // get panel it's on top of
            //     var allDivsHere = getAllDivsUnderCoordinate(mouseX, mouseY);
            //     allDivsHere.forEach( function(element) {
            //         if (element.classList.contains('region') &&  element.id.startsWith('panel_') && element.id !== 'panel_row0_col0') {
            //             console.log('released on panel');
            //             panelVisualizationTypes[element.id] = currentlyDraggedPanel.id;
            //             setPanelDisplay(element, currentlyDraggedPanel.id);
            //         }
            //     });
            //
            //     document.getElementsByTagName('body')[0].removeChild(currentlyDraggedPanel);
            //     currentlyDraggedPanel = null;
            // }

            if (currentlyDraggedPanel) {
                // post new position to server
                var content = frames[currentlyDraggedPanel.dataset.frameKey].screen;

                urlEndpoint = 'http://' + SERVER_IP + ':' + SERVER_PORT + '/object/' + currentlyDraggedPanel.dataset.objectKey + "/frame/" + currentlyDraggedPanel.dataset.frameKey + "/node/" + currentlyDraggedPanel.dataset.nodeKey + "/size/";

                // console.log('url endpoint = ' + urlEndpoint);
                postData(urlEndpoint, content);

            }

            currentlyDraggedPanel = null;

            socket.emit('writeScreenObject', {objectKey: null, frameKey: null, nodeKey: null});
            console.log('writeScreenObject null');

        }
    }

    function getAllDivsUnderCoordinate(x, y) {
        var res = [];
        var previousDisplayTypes = [];

        var ele = document.elementFromPoint(x,y);
        while(ele && ele.tagName !== "BODY" && ele.tagName !== "HTML"){
            res.push(ele);
            previousDisplayTypes.push(ele.style.display);
            ele.style.display = "none";
            ele = document.elementFromPoint(x,y);
        }

        for(var i = 0; i < res.length; i++){
            res[i].style.display = previousDisplayTypes[i];
        }
        // console.log(res);
        return res;
    }

    // ..... UTILITIES ..... //

    function createPanelElements(type) {
        var sidebarPanelClone = createSidebarPanel(type); //clickedPanelContainer.id
        sidebarPanelClone.classList.add("region");
        sidebarPanelClone.classList.add("smallText");
        currentlyDraggedPanel = sidebarPanelClone;
        startDragZ = mostRecentZ || DEFAULT_START_DRAG_Z;
        currentlyDraggedPanel.style.position = "absolute";
        document.getElementsByTagName('body')[0].appendChild(currentlyDraggedPanel);
        sidebarPanelClone.classList.add("draggedPanel");
    }

    // copied from userinterface realityEditor.device.utilities.uuidTime
    function uuidTime() {
        var dateUuidTime = new Date();
        var abcUuidTime = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        var stampUuidTime = parseInt(Math.floor((Math.random() * 199) + 1) + "" + dateUuidTime.getTime()).toString(36);
        while (stampUuidTime.length < 12) stampUuidTime = abcUuidTime.charAt(Math.floor(Math.random() * abcUuidTime.length)) + stampUuidTime;
        return stampUuidTime;
    }

    function FrameTouchSynthesizer(cover, iframe) {
        this.cover = cover;
        this.iframe = iframe;
        this.beginTouchEditing = this.beginTouchEditing.bind(this);
        this.onPointerEvent = this.onPointerEvent.bind(this);
        this.cover.addEventListener('pointerdown', this.onPointerEvent);
        this.cover.addEventListener('pointermove', this.onPointerEvent);
        this.cover.addEventListener('pointerup', this.onPointerEvent);
        this.cover.addEventListener('pointercancel', this.onPointerEvent);
    }

    FrameTouchSynthesizer.prototype.onPointerEvent = function(event) {
        event.stopPropagation();

        // Note that this is a legacy API that the GeometryUtils should eventually replace
        var newCoords = webkitConvertPointFromPageToNode(this.iframe, new WebKitPoint(event.pageX, event.pageY));
        this.iframe.contentWindow.postMessage(JSON.stringify({
            event: {
                type: event.type,
                pointerId: event.pointerId,
                pointerType: event.pointerType,
                x: newCoords.x,
                y: newCoords.y
            }
        }), '*');

        if (event.type === 'pointerdown') {
            this.start = {
                x: event.pageX,
                y: event.pageY
            };
            this.timer = setTimeout(this.beginTouchEditing, 400);
        } else if (event.type === 'pointermove') {
            if (this.timer) {
                var dx = event.pageX - this.start.x;
                var dy = event.pageY - this.start.y;
                if (dx * dx + dy * dy > touchMoveTolerance) {
                    clearTimeout(this.timer);
                    this.timer = null;
                }
            }
        } else {
            if (this.timer) {
                clearTimeout(this.timer);
                this.timer = null;
            }
        }
    };

    FrameTouchSynthesizer.prototype.beginTouchEditing = function() {
        var activeKey = this.iframe.dataset.nodeKey;
        if (!activeKey || activeKey === "null") {
            activeKey = this.iframe.dataset.frameKey;
        }
        realityEditor.device.beginTouchEditing(document.getElementById(activeKey));
    };

    FrameTouchSynthesizer.prototype.remove = function() {
        this.cover.removeEventListener('pointerdown', this.onPointerEvent);
        this.cover.removeEventListener('pointermove', this.onPointerEvent);
        this.cover.removeEventListener('pointerup', this.onPointerEvent);
        this.cover.removeEventListener('pointercancel', this.onPointerEvent);
    };

</script>

</body>
</html>
