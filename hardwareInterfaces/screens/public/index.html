<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Frame Screen</title>
    <link rel="stylesheet" type="text/css" href="index.css">
    <style>
        .screenFrame {
            display: inline;
            /*opacity: 1.0;*/
            transform-origin: left top;
        }

        .arFrame {
            display: none;
            /*opacity: 0.1;*/
            transform-origin: left top;
        }
        body, html {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        .bg {
            /* The image used */
            /*background-image: url("resources/frameScreen.jpg");*/

            /* Full height */
            height: 100%;

            /* Center and scale the image nicely */
            background-position: center;
            background-repeat: no-repeat;
            background-size: cover;
        }
        .frame {
            transform-origin: left top;
        }
    </style>
</head>
<body>

<div class="bg"></div>

<script src="/socket.io/socket.io.js"></script>
<script src="resources/pep.min.js"></script>

<script>
    var scaleARFactor = 1.5;
    console.log(location.origin.split(":")[1].split("//")[1]);
    var SERVER_IP = location.origin.split(":")[1].split("//")[1]; //'192.168.56.7'; //'10.0.0.245'; //'10.68.23.38';
    var SERVER_PORT = '8080';

    // var thisObjectName = location.search.split('objectName')[1].split('=')[1];
    // document.querySelector('.bg').style.backgroundImage = 'url("resources/'+thisObjectName+'.jpg")';

    var frames = {};
    var socket = io();

    // constants
    var AR_MARKER_SIZE = 300.0;

    // variables for drag interface
    var currentlyDraggedPanel = null;
    var dragOffsetX = null;
    var dragOffsetY = null;

    window.requestAnimFrame = function(){
        return (
            window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame     ||
            function(/* function */ callback){
                window.setTimeout(callback, 1000 / 60);
            }
        );
    }();

    window.onload = function() {

        initializeDragInterface();

        window.addEventListener("message", onInternalPostMessage, false);

        socket.emit('getObjectName');
        // callback to set background image based on objectName
        socket.on('objectName', function(msg) {
            document.querySelector('.bg').style.backgroundImage = 'url("resources/'+msg.objectName+'.jpg")';
        });

        socket.emit('getFramesForScreen');

        // callback to load the frames from the server
        socket.on('framesForScreen', function(msg) {
            console.log('framesForScreen', msg);
            frames = msg;
            renderFrames();
        });

        // callback for when the screenObject data structure is updated in the editor based on projected touch events
        socket.on('screenObject', function(msg) {
            var screenPos = getScreenPosFromARPos(msg.x, msg.y);
            // console.log(msg);
            // console.log(screenPos.x + ', ' + screenPos.y);
            // console.log(msg.touchState);

            if (msg.touchState === 'touchstart') {
                console.log('touchstart');
                simulateMouseEvent(screenPos.x, screenPos.y, 'mousedown');

            }

            if (msg.object && msg.frame) {
                console.log('set visibility: ' + msg.isScreenVisible + ' for object ' + msg.object + ', frame ' + msg.frame);
                var frame = frames[msg.frame];
                if (frame) {
                    var oldVisualization = frame.visualization;
                    frame.visualization = msg.isScreenVisible ? 'screen' : 'ar';

                    var iframeId = "iframe" + msg.frame;
                    var iframe = document.querySelector('#'+iframeId);
                    if (iframe) {
                        currentlyDraggedPanel = iframe;
                    }

                    // set scale of screen frame to match AR frame's size
                    if (frame.visualization === 'screen' && oldVisualization === 'ar' && msg.scale !== frame.screen.scale) {
                        frame.ar.scale = msg.scale;
                        frame.screen.scale = msg.scale * scaleARFactor;
                        if (iframe) {
                            iframe.parentElement.style.transform = 'scale(' + frame.screen.scale + ')';

                            if (msg.touchOffsetX) {
                                dragOffsetX = -1 * msg.touchOffsetX;// + 200;// / getScreenScaleFactor();
                            }
                            if (msg.touchOffsetY) {
                                dragOffsetY = -1 * msg.touchOffsetY;// + 200;// / getScreenScaleFactor();
                            }
                            console.log('received touchOffset', msg.touchOffsetX, msg.touchOffsetY);
                        }
                    }
                }
            }

            if (msg.touchState === 'touchmove') {
                simulateMouseEvent(screenPos.x, screenPos.y, 'mousemove');

            } else if (msg.touchState === 'touchend') {
                console.log('touchend');
                simulateMouseEvent(screenPos.x, screenPos.y, 'mouseup');
                currentlyDraggedPanel = null;
                dragOffsetX = null;
                dragOffsetY = null;
            }

        });

        // callback for when new frames get created in AR --> we need to create a copy here too
        socket.on('frameDataCallback', function(frame) {
            console.log('frameDataCallback', frame);
            var frameKey = getFrameKey(frame);
            frames[frameKey] = frame;
            frame.screen.scale = frame.ar.scale * scaleARFactor;
            // TODO: set screen position based on AR position??
        });

    };

    function renderFrames() {
        // console.log('renderFrames');
        for (var frameKey in frames) {
            if (!frames.hasOwnProperty(frameKey)) continue;
            var frame = frames[frameKey];
            if (typeof frame.type === 'undefined') continue;

            addElement(frameKey, frame);
            drawTransformed(frameKey, frame);
        }

        requestAnimFrame(renderFrames);
    }

    function addElement(frameKey, frame) {
        var iframeId = "iframe" + frameKey;
        var iframeExists = document.querySelectorAll('#'+iframeId).length > 0;

        if (!iframeExists) {

            if (!frame.hasOwnProperty('width')) {
                frame.width = 300;
            }
            if (!frame.hasOwnProperty('height')) {
                frame.height = 200;
            }

            frame.screen.scale = frame.ar.scale * scaleARFactor;

            // frame.screen.scale = frame.ar.scale;
            if (frame.screen.x === 0 && frame.screen.y === 0 && (frame.ar.x !== 0 || frame.ar.y !== 0)) {
                // getScreenPosFromARPos(getScreenFrames()[2].ar.x, getScreenFrames()[2].ar.y)
                var screenPosConversion = getScreenPosFromARPos(frame.ar.x, frame.ar.y);
                frame.screen.x = screenPosConversion.x;
                frame.screen.y = screenPosConversion.y;
            }

            var scaleFactor = getScreenScaleFactor();
            var screenFrameWidth = (frame.width);// * frame.screen.scale;
            var screenFrameHeight = (frame.height);// * frame.screen.scale;

            var addContainer = document.createElement('div');
            addContainer.id = "object" + frameKey;
            // addContainer.className = "main";
            addContainer.classList.add('main', 'arFrame');
            // addContainer.style.display = "none";
            addContainer.style.border = 0;
            addContainer.style.position = 'absolute';
            var screenPos = getScreenPosFromARPos(frame.screen.x, frame.screen.y);
            addContainer.style.left = screenPos.x + "px"; //frame.screen.x + "px";
            addContainer.style.top = screenPos.y + "px"; //frame.screen.y + "px";
            addContainer.style.transform = 'scale(' + frame.screen.scale + ')';

            var addIframe = document.createElement('iframe');
            addIframe.id = iframeId;
            addIframe.classList.add('main', 'frame');
            addIframe.frameBorder = 0;
            addIframe.style.width = (screenFrameWidth || 0) + "px";
            addIframe.style.height = (screenFrameHeight || 0) + "px";
            // addIframe.style.transform = 'scale(' + frame.screen.scale + ')';

            addIframe.style.visibility = "visible";
            // addIframe.style.pointerEvents = 'none';
            addIframe.src = 'http://' + SERVER_IP + ':' + SERVER_PORT + '/frames/' + frame.type + '.html';
            // addIframe.src = '/frames/' + frame.type + '.html';
            addIframe.dataset.nodeKey = null;
            addIframe.dataset.frameKey = frameKey;
            addIframe.dataset.objectKey = frame.objectId;
            addIframe.setAttribute("onload", 'onElementLoad(\"' + frame.objectId + '\",\"' + frameKey + '\")');
            addIframe.setAttribute("sandbox", "allow-forms allow-pointer-lock allow-same-origin allow-scripts");
            document.body.appendChild(addIframe);
            addIframe.display = 'inline';

            // add a cover object for touch event synthesizing
            var cover = document.createElement('div');
            cover.classList.add('main');
            cover.style.visibility = 'visible';
            cover.style.width = addIframe.style.width;
            cover.style.height = addIframe.style.height;
            cover.style.top = 0;
            cover.style.left = 0;
            cover.style.position = 'absolute';
            // frame.frameTouchSynthesizer = new FrameTouchSynthesizer(cover, addIframe);

            document.body.appendChild(addContainer);
            addContainer.appendChild(addIframe);
            addContainer.appendChild(cover);
        }
    }

    function onElementLoad (objectKey, frameKey) {
        console.log('onElementLoad ' + objectKey + ' ' + frameKey);

        var newStyle = {
            object: objectKey,
            frame: frameKey,
            objectData: {
                ip: SERVER_IP
            },
            node: null,
            nodes: null,
            interface: null
        };
        var thisIframe = document.querySelector("#iframe" + frameKey);
        thisIframe._loaded = true;
        thisIframe.contentWindow.postMessage(JSON.stringify(newStyle), '*');
        thisIframe.contentWindow.postMessage(JSON.stringify({
            resizeFrameData: {
                width: parseInt(thisIframe.style.width),
                height: parseInt(thisIframe.style.height)
            }
        }), '*');


        console.log("on_load");
    }

    function drawTransformed(frameKey, frame) {
        var frameContainerDom = document.querySelector('#object'+frameKey);
        if (frame.visualization === 'screen') {
            // frameContainerDom.style.display = 'inline';
            frameContainerDom.classList.remove('arFrame');
            frameContainerDom.classList.add('screenFrame');
            frameContainerDom.style.left = frame.screen.x + 'px';
            frameContainerDom.style.top = frame.screen.y + 'px';
        } else {
            // frameContainerDom.style.display = 'none';
            frameContainerDom.classList.remove('screenFrame');
            frameContainerDom.classList.add('arFrame');
            var arPos = getARPosFromScreenPos(frame.screen.x, frame.screen.y);
            frameContainerDom.style.left = arPos.x + 'px';
            frameContainerDom.style.top = arPos.y + 'px';
        }
    }

    /**
     * Helper function for debugging which frames are in the screen.
     */
    function getScreenFrames() {
        var screenFrames = [];
        for (var frameKey in frames) {
            if (!frames.hasOwnProperty(frameKey)) continue;
            if (frames[frameKey].visualization === 'screen') {
                screenFrames.push(frames[frameKey]);
            }
        }
        return screenFrames;
    }

    /**
     * Helper function for debugging which frames are in AR.
     */
    function getARFrames() {
        var arFrames = [];
        for (var frameKey in frames) {
            if (!frames.hasOwnProperty(frameKey)) continue;
            if (frames[frameKey].visualization === 'ar') {
                arFrames.push(frames[frameKey]);
            }
        }
        return arFrames;
    }

    function getFrameKey(frame) {
        return frame.uuid || frame.objectId + frame.name;
    }

    function getMarkerRect() {
        var windowWidth = window.innerWidth;
        var windowHeight = window.innerHeight;

        var markerWidth = 600;
        var markerHeight = 600;

        var rect = {
            x: (windowWidth/2 - markerWidth/2),
            y: (windowHeight/2 - markerHeight/2),
            width: markerWidth,
            height: markerHeight
        };

        return rect;
    }

    /**
     * Set the width and height of each iframe based on its contents, which it automatically posts
     */
    function onInternalPostMessage(e) {
        var msgContent = {};
        if (e.data) {
            if (typeof e.data === 'string') {
                msgContent = JSON.parse(e.data);
            } else {
               return;
            }
        } else {
            if (typeof e === 'string') {
                msgContent = JSON.parse(e);
            } else {
                return;
            }
        }

        console.log(msgContent);

        if (msgContent.width && msgContent.height) {
            console.log('got width and height', msgContent.width, msgContent.height);
            var iFrame = document.getElementById('iframe' + msgContent.frame);
            iFrame.style.width = msgContent.width + 'px';
            iFrame.style.height = msgContent.height + 'px';
        }
    }

    function simulateMouseEvent(x,y,eventName) {
        mouseX = x;// * 2.0;
        mouseY = y;// * 2.0;

        var ev = new MouseEvent(eventName, {
            'view': window,
            'bubbles': true,
            'cancelable': true,
            'screenX': x,
            'screenY': y
        });
        ev.simulated = true;

        // el is null if x,y is outside window boundaries
        var el = document.elementFromPoint(x, y);
        if (el) {
            el.dispatchEvent(ev);
        }
    }

    function initializeDragInterface() {

        var kStates = Object.freeze({
            NONE: 0,
            CLICK: 1,
            DRAG: 2
        });

        var kActions = Object.freeze({
            NONE: 0,
            MOUSE_DOWN: 1,
            MOUSE_MOVE: 2,
            MOUSE_UP: 3,
            MOUSE_CANCEL: 4
        });

        var kEvents = Object.freeze({
            MOUSE_START_CLICK: 0,
            MOUSE_STOP_CLICK: 1,
            MOUSE_START_DRAG: 2,
            MOUSE_STOP_DRAG: 3
        });

        // add event listeners for mouse down, up, move, (cancel?)
        document.addEventListener('pointerdown', onMouseDown);
        document.addEventListener('pointermove', onMouseMove);
        document.addEventListener('pointerup', onMouseUp);
        // document.addEventListener('mouseout', onMouseUpdate, false);

        var interactionState = kStates.NONE;

        function onMouseDown(e) {
            interactionState = performAction(kActions.MOUSE_DOWN, interactionState);
        }

        function onMouseMove(e) {
            mouseX = e.screenX;
            mouseY = e.screenY;

            interactionState = performAction(kActions.MOUSE_MOVE, interactionState);

            if (currentlyDraggedPanel) {
                var frame = frames[currentlyDraggedPanel.dataset.frameKey];
                frame.screen.x = mouseX + (dragOffsetX || 0);
                frame.screen.y = mouseY + (dragOffsetY || 0);
            }
        }

        function onMouseUp(e) {
            interactionState = performAction(kActions.MOUSE_UP, interactionState);
        }

        // maintain a state machine that triggers actions upon entering each state

        function performAction(action, currentState) {

            if (action === kActions.MOUSE_DOWN) {
                if (currentState === kStates.NONE) {
                    triggerEvent(kEvents.MOUSE_START_CLICK);
                    return kStates.CLICK;
                }

            } else if (action === kActions.MOUSE_MOVE) {
                if (currentState === kStates.CLICK) {
                    triggerEvent(kEvents.MOUSE_START_DRAG);
                    return kStates.DRAG;
                }

            } else if (action === kActions.MOUSE_UP || action === kActions.MOUSE_CANCEL) {
                if (currentState === kStates.CLICK) {
                    triggerEvent(kEvents.MOUSE_STOP_CLICK)
                } else if (currentState === kStates.DRAG) {
                    triggerEvent(kEvents.MOUSE_STOP_DRAG);
                }
                return kStates.NONE;
            }

            return currentState;
        }

        function triggerEvent(event) {
            switch (event) {
                case kEvents.MOUSE_START_CLICK:
                    startClick();
                    break;
                case kEvents.MOUSE_START_DRAG:
                    startDrag();
                    break;
                case kEvents.MOUSE_STOP_CLICK:
                    stopClick();
                    break;
                case kEvents.MOUSE_STOP_DRAG:
                    stopDrag();
                    break;
                default:
                    console.warn("mouse event shouldn't happen");
            }
        }

        function isDraggableElement(clickedElement) {
            return (clickedElement.classList.contains('frame') && clickedElement.style.display !== 'none');
        }

        function startClick() {
            var allDivsHere = getAllDivsUnderCoordinate(mouseX, mouseY);
            allDivsHere.some( function(clickedElement) {
                if (isDraggableElement(clickedElement)) {
                    currentlyDraggedPanel = clickedElement;
                    dragOffsetX = currentlyDraggedPanel.getBoundingClientRect().x - mouseX;
                    dragOffsetY = currentlyDraggedPanel.getBoundingClientRect().y - mouseY;
                    socket.emit('writeScreenObject', {objectKey: currentlyDraggedPanel.dataset.objectKey, frameKey: currentlyDraggedPanel.dataset.frameKey, nodeKey: currentlyDraggedPanel.dataset.nodeKey, touchOffsetX: dragOffsetX, touchOffsetY: dragOffsetY});
                }
                return (!!currentlyDraggedPanel);
            });
        }

        function startDrag() {
            console.log('startDrag');
        }

        function stopClick() {
            socket.emit('writeScreenObject', {objectKey: null, frameKey: null, nodeKey: null, touchOffsetX: 0, touchOffsetY: 0});
            console.log('writeScreenObject null (stopClick)');
            currentlyDraggedPanel = null;
        }

        function stopDrag() {

            // TODO: figure out a way to still update this data to persist state, without making action sender reload the associated AR object
            /*
            if (currentlyDraggedPanel) {
                // post new position to server
                var content = frames[currentlyDraggedPanel.dataset.frameKey].screen;

                urlEndpoint = 'http://' + SERVER_IP + ':' + SERVER_PORT + '/object/' + currentlyDraggedPanel.dataset.objectKey + "/frame/" + currentlyDraggedPanel.dataset.frameKey + "/node/" + currentlyDraggedPanel.dataset.nodeKey + "/size/";

                // console.log('url endpoint = ' + urlEndpoint);
                postData(urlEndpoint, content);

            }
            */

            socket.emit('writeScreenObject', {objectKey: null, frameKey: null, nodeKey: null, touchOffsetX: 0, touchOffsetY: 0});
            console.log('writeScreenObject null (stopDrag)');
            currentlyDraggedPanel = null;

        }
    }

    // ... UTILITIES ... //

    // ........ DOM manipulation ........ //

    /**
     * Utility for getting scale factor between screen coordinates and AR marker coordinates.
     * @return {number} scale factor. 1 means they are the same and 0.5 means marker in AR is half as big as marker on screen.
     */
    function getScreenScaleFactor() {
        var markerRect = getMarkerRect();
        return AR_MARKER_SIZE / markerRect.height;
    }

    /**
     * Utility for converting coordinates from AR space to screen space.
     * @param {number} arX - x coordinate in AR space relative to center of marker.
     * @param {number} arY - y coordinate in AR space relative to center of marker.
     * @return {{x: number, y: number}}
     */
    function getScreenPosFromARPos(arX, arY) {
        var markerRect = getMarkerRect();
        var scaleFactor = getScreenScaleFactor();
        var screenX = (markerRect.x + markerRect.width/2) + (arX / scaleFactor)*(scaleARFactor/2);
        var screenY = (markerRect.y + markerRect.height/2) + (arY / scaleFactor)*(scaleARFactor/2);
        return {
            x: screenX,
            y: screenY
        };
    }

    /**
     * Utility for converting coordinates from screen space to AR space.
     * @param {number} screenX - x coordinate relative to upper left of screen.
     * @param {number} screenY - y coordinate relative to upper left of screen.
     * @return {{x: number, y: number}}
     */
    function getARPosFromScreenPos(screenX, screenY) {
        var markerRect = getMarkerRect();
        var scaleFactor = getScreenScaleFactor();
        var arX = (screenX - (markerRect.x + markerRect.width/2)) * scaleFactor;
        var arY = (screenY - (markerRect.y + markerRect.height/2)) * scaleFactor;
        return {
            x: arX,
            y: arY
        };
    }

    /**
     * Given an x, y coordinate, returns a list of DOM elements intersecting that coordinate
     */
    function getAllDivsUnderCoordinate(x, y) {
        var res = [];
        var previousDisplayTypes = [];

        var ele = document.elementFromPoint(x,y);
        while(ele && ele.tagName !== "BODY" && ele.tagName !== "HTML"){
            res.push(ele);
            previousDisplayTypes.push(ele.style.display);
            ele.style.display = "none";
            ele = document.elementFromPoint(x,y);
        }

        for(var i = 0; i < res.length; i++){
            res[i].style.display = previousDisplayTypes[i];
        }
        // console.log(res);
        return res;
    }

    // ........ Networking ........ //

    function getData(objectKey, frameKey, nodeKey, url, callback) {
        if (!nodeKey) nodeKey = null;
        if (!frameKey) frameKey = null;
        var _this = this;
        var req = new XMLHttpRequest();
        try {
            console.log('making GET request to ' + url);
            req.open('GET', url, true);
            // Just like regular ol' XHR
            req.onreadystatechange = function () {
                if (req.readyState === 4) {
                    if (req.status === 200) {
                        // JSON.parse(req.responseText) etc.
                        if (req.responseText)
                            callback(objectKey, frameKey, nodeKey, JSON.parse(req.responseText));
                    } else {
                        // Handle error case
                        console.log("could not load content");
                        _this.cout("could not load content");
                    }
                }
            };
            req.send();

        }
        catch (e) {
            this.cout("could not connect to" + url);
        }
    }

    /**
     * POST data as json to url, calling callback with the
     * JSON-encoded response data when finished
     * @param {String} url
     * @param {Object} body
     * @param {Function<Error, Object>} callback
     */
    function postData (url, body, callback) {
        var request = new XMLHttpRequest();
        var params = JSON.stringify(body);
        request.open('POST', url, true);
        request.onreadystatechange = function () {
            if (request.readyState !== 4) {
                return;
            }
            if (!callback) {
                return;
            }

            if (request.status === 200) {
                try {
                    callback(null, JSON.parse(request.responseText));
                } catch (e) {
                    callback({status: request.status, error: e, failure: true}, null);
                }
                return;
            }

            callback({status: request.status, failure: true}, null);
        };

        request.setRequestHeader("Content-type", "application/json");
        //request.setRequestHeader("Content-length", params.length);
        // request.setRequestHeader("Connection", "close");
        request.send(params);
    }

    // ........ FrameTouchSynthesizer ........ //

    /**
     * Given a cover and an iframe, synthesizes touch events to post into the iframe contents
     * without losing context of the outside application
     * @param cover
     * @param iframe
     * @constructor
     */
    function FrameTouchSynthesizer(cover, iframe) {
        this.cover = cover;
        this.iframe = iframe;
        this.beginTouchEditing = this.beginTouchEditing.bind(this);
        this.onPointerEvent = this.onPointerEvent.bind(this);
        this.cover.addEventListener('pointerdown', this.onPointerEvent);
        this.cover.addEventListener('pointermove', this.onPointerEvent);
        this.cover.addEventListener('pointerup', this.onPointerEvent);
        this.cover.addEventListener('pointercancel', this.onPointerEvent);
    }

    /*
    FrameTouchSynthesizer.prototype.onPointerEvent = function(event) {
        event.stopPropagation();

        // Note that this is a legacy API that the GeometryUtils should eventually replace
        var newCoords = webkitConvertPointFromPageToNode(this.iframe, new WebKitPoint(event.pageX, event.pageY));
        this.iframe.contentWindow.postMessage(JSON.stringify({
            event: {
                type: event.type,
                pointerId: event.pointerId,
                pointerType: event.pointerType,
                x: newCoords.x,
                y: newCoords.y
            }
        }), '*');

        if (event.type === 'pointerdown') {
            this.start = {
                x: event.pageX,
                y: event.pageY
            };
            this.timer = setTimeout(this.beginTouchEditing, 400);
        } else if (event.type === 'pointermove') {
            if (this.timer) {
                var dx = event.pageX - this.start.x;
                var dy = event.pageY - this.start.y;
                if (dx * dx + dy * dy > touchMoveTolerance) {
                    clearTimeout(this.timer);
                    this.timer = null;
                }
            }
        } else {
            if (this.timer) {
                clearTimeout(this.timer);
                this.timer = null;
            }
        }
    };

    FrameTouchSynthesizer.prototype.beginTouchEditing = function() {
        var activeKey = this.iframe.dataset.nodeKey;
        if (!activeKey || activeKey === "null") {
            activeKey = this.iframe.dataset.frameKey;
        }
        realityEditor.device.beginTouchEditing(document.getElementById(activeKey));
    };

    FrameTouchSynthesizer.prototype.remove = function() {
        this.cover.removeEventListener('pointerdown', this.onPointerEvent);
        this.cover.removeEventListener('pointermove', this.onPointerEvent);
        this.cover.removeEventListener('pointerup', this.onPointerEvent);
        this.cover.removeEventListener('pointercancel', this.onPointerEvent);
    };
    */

</script>

</body>
</html>
