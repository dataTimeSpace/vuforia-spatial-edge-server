<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Frame Screen</title>
    <link rel="stylesheet" type="text/css" href="index.css">
</head>
<body>

<div class="bg"></div>
<canvas id="canvas"></canvas>
<div id="touchOverlay"></div>

<script src="src/index.js"></script>

<script src="src/draw.js"></script>
<script src="src/moveabilityOverlay.js"></script>
<script src="src/network.js"></script>
<script src="src/touchEvents.js"></script>
<script src="src/utilities.js"></script>

<script src="/socket.io/socket.io.js"></script>
<script src="resources/pep.min.js"></script>

<script>
    var scaleARFactor = 1.5;

    // get the url of the reality server to load frames from and to post new frame positions
    var SERVER_IP = location.origin.split(":")[1].split("//")[1];
    var SERVER_PORT = '8080';
    console.log('screen found Reality Server at address:   http://' + SERVER_IP + ':' + SERVER_PORT);

    var frames = {};
    var socket = io();

    // constants
    var AR_MARKER_SIZE = 300.0;

    var windowToEditorRatio = 1;

    // difference between touchscreen is mousemove events trigger regardless of whether clicking down (so need to keep track ourselves)
    var isMouseDown = false;

    /**
     * @typedef {Object} EditingState
     * @desc All the necessary state about what's currently being repositioned. Everything else can be calculated from these.
     * @property {string|null} objectKey
     * @property {string|null} frameKey
     * @property {string|null} nodeKey
     * @property {{x: number, y: number}|null} touchOffset
     * @property {boolean} unconstrained
     */

    /**
     * @type {EditingState}
     */
    var editingState = {
        objectKey: null,
        frameKey: null,
        nodeKey: null,
        touchOffset: null
        // unconstrained: false,
        // unconstrainedOffset: null
    };


    /**
     * @type {List.<{x: number, y: number, type: string}>}
     */
    var multiTouchList = [];

    var touchEditingTimer = null;

    /**
     * @typedef initialScaleData
     * @property radius {number} how far apart in pixels the two touches are to begin with
     * @property scale {number} the frame or node's initial scale value before the gesture, to use as a base multiplier
     */
    var initialScaleData = null;

    var touchOverlay;

    var globalCanvas = {};
    globalCanvas.canvas = document.getElementById('canvas');
    globalCanvas.canvas.width = window.innerWidth;
    globalCanvas.canvas.height = window.innerHeight;
    globalCanvas.context = globalCanvas.canvas.getContext('2d');

    window.requestAnimFrame = function(){
        return (
            window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame     ||
            function(/* function */ callback){
                window.setTimeout(callback, 1000 / 60);
            }
        );
    }();

    window.onload = function() {

        windowToEditorRatio = Math.max(1, Math.round((window.innerWidth/568)));
        touchOverlay = document.getElementById('touchOverlay');
        touchOverlay.style.width = (60 * windowToEditorRatio) + 'px';
        touchOverlay.style.height = (60 * windowToEditorRatio) + 'px';
        touchOverlay.style.marginLeft = (-30 * windowToEditorRatio) + 'px';
        touchOverlay.style.marginTop = (-30 * windowToEditorRatio) + 'px';
        touchOverlay.style.borderRadius = (60 * windowToEditorRatio) + 'px';
        touchOverlay.style.border = (4 * windowToEditorRatio) + 'px solid #01fffc';

        realityEditor.touchEvents.addTouchListeners();

        realityEditor.network.setupSocketListeners();

        window.addEventListener("message", realityEditor.network.onInternalPostMessage, false);

        socket.emit('getObjectName');
        socket.emit('getFramesForScreen');
    };

    /**
     * Helper function for debugging which frames are in the screen.
     */
    function getScreenFrames() {
        var screenFrames = [];
        for (var frameKey in frames) {
            if (!frames.hasOwnProperty(frameKey)) continue;
            if (frames[frameKey].visualization === 'screen') {
                screenFrames.push(frames[frameKey]);
            }
        }
        return screenFrames;
    }

    /**
     * Helper function for debugging which frames are in AR.
     */
    function getARFrames() {
        var arFrames = [];
        for (var frameKey in frames) {
            if (!frames.hasOwnProperty(frameKey)) continue;
            if (frames[frameKey].visualization === 'ar') {
                arFrames.push(frames[frameKey]);
            }
        }
        return arFrames;
    }

    function getFrameKey(frame) {
        return frame.uuid || frame.objectId + frame.name;
    }

    function getMarkerRect() {
        var windowWidth = window.innerWidth;
        var windowHeight = window.innerHeight;

        var markerWidth = 600;
        var markerHeight = 600;

        var rect = {
            x: (windowWidth/2 - markerWidth/2),
            y: (windowHeight/2 - markerHeight/2),
            width: markerWidth,
            height: markerHeight
        };

        return rect;
    }

    function simulateMouseEvent(x,y,eventName,multiTouchList) {
        mouseX = x;// * 2.0;
        mouseY = y;// * 2.0;

        var ev = new MouseEvent(eventName, {
            'view': window,
            'bubbles': true,
            'cancelable': true,
            'screenX': x,
            'screenY': y,
            'touches': multiTouchList
        });
        ev.simulated = true;

        // el is null if x,y is outside window boundaries
        var el = document.elementFromPoint(x, y);
        if (el) {
            el.dispatchEvent(ev);
        } else {
            document.dispatchEvent(ev); // if you are outside the bounds, still try to move it
        }
    }

    // ... UTILITIES ... //

    // ........ DOM manipulation ........ //

    /**
     * Utility for getting scale factor between screen coordinates and AR marker coordinates.
     * @return {number} scale factor. 1 means they are the same and 0.5 means marker in AR is half as big as marker on screen.
     */
    function getScreenScaleFactor() {
        var markerRect = getMarkerRect();
        return AR_MARKER_SIZE / markerRect.height;
    }

    /**
     * Utility for converting coordinates from AR space to screen space.
     * @param {number} arX - x coordinate in AR space relative to center of marker.
     * @param {number} arY - y coordinate in AR space relative to center of marker.
     * @return {{x: number, y: number}}
     */
    function getScreenPosFromARPos(arX, arY) {
        var markerRect = getMarkerRect();
        var scaleFactor = getScreenScaleFactor();
        var screenX = (markerRect.x + markerRect.width/2) + (arX / scaleFactor)*(scaleARFactor/2);
        var screenY = (markerRect.y + markerRect.height/2) + (arY / scaleFactor)*(scaleARFactor/2);
        return {
            x: screenX,
            y: screenY
        };
    }

    /**
     * Utility for converting coordinates from screen space to AR space.
     * @param {number} screenX - x coordinate relative to upper left of screen.
     * @param {number} screenY - y coordinate relative to upper left of screen.
     * @return {{x: number, y: number}}
     */
    function getARPosFromScreenPos(screenX, screenY) {
        var markerRect = getMarkerRect();
        var scaleFactor = getScreenScaleFactor();
        var arX = (screenX - (markerRect.x + markerRect.width/2)) * scaleFactor;
        var arY = (screenY - (markerRect.y + markerRect.height/2)) * scaleFactor;
        return {
            x: arX,
            y: arY
        };
    }

    /**
     * Given an x, y coordinate, returns a list of DOM elements intersecting that coordinate
     */
    function getAllDivsUnderCoordinate(x, y) {
        var res = [];
        var previousDisplayTypes = [];

        var ele = document.elementFromPoint(x,y);
        while(ele && ele.tagName !== "BODY" && ele.tagName !== "HTML"){
            res.push(ele);
            previousDisplayTypes.push(ele.style.display);
            ele.style.display = "none";
            ele = document.elementFromPoint(x,y);
        }

        for(var i = 0; i < res.length; i++){
            res[i].style.display = previousDisplayTypes[i];
        }
        // console.log(res);
        return res;
    }

</script>

</body>
</html>
